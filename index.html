<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Quill : Compile-time Language Integrated Query for Scala">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Quill</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/getquill/quill">View on GitHub</a>

          <h1 id="project_title">Quill</h1>
          <h2 id="project_tagline">Compile-time Language Integrated Query for Scala</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/getquill/quill/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/getquill/quill/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>Quill provides a Quoted Domain Specific Language (<a href="http://homepages.inf.ed.ac.uk/slindley/papers/qdsl-draft-february2015.pdf">QDSL</a>) to express queries in Scala and execute them in a target language. The library's core is designed to support multiple target languages and the current version features support for Structured Query Language (<a href="https://en.wikipedia.org/wiki/SQL">SQL</a>).</p>

<p><img src="https://raw.githubusercontent.com/getquill/quill/master/example.gif" alt="example"></p>

<ol>
<li>
<strong>Boilerplate-free mapping</strong>: The database schema is mapped using simple case classes.</li>
<li>
<strong>Quoted DSL</strong>: Queries are defined inside a <code>quote</code> block. Quill parses each quoted block of code (quotation) at compile time and translates them to an internal Abstract Syntax Tree (AST)</li>
<li>
<strong>Compile-time SQL generation</strong>: The <code>db.run</code> call reads the quotation's AST and translates it to the target language at compile time, emitting the SQL string as a compilation message. As the query string is known at compile time, the runtime overhead is very low and similar to using the database driver directly.</li>
<li>
<strong>Compile-time query validation</strong>: If configured, the query is verified against the database at compile time and the compilation fails if it is not valid.</li>
</ol>

<h1>
<a id="index" class="anchor" href="#index" aria-hidden="true"><span class="octicon octicon-link"></span></a>Index</h1>

<ul>
<li><a href="#quotation">Quotation</a></li>
<li><a href="#mirror-sources">Mirror sources</a></li>
<li><a href="#compile-time-quotations">Compile-time quotations</a></li>
<li><a href="#parametrized-quotations">Parametrized quotations</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#queries">Queries</a></li>
<li><a href="#actions">Actions</a></li>
<li><a href="#dynamic-queries">Dynamic queries</a></li>
<li>
<a href="#extending-quill">Extending quill</a>

<ul>
<li><a href="#infix">Infix</a></li>
<li><a href="#custom-encoding">Custom encoding</a></li>
</ul>
</li>
<li>
<a href="#sources">Sources</a>

<ul>
<li><a href="#dialect">Dialect</a></li>
<li><a href="#naming-strategy">Naming strategy</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
</li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#license">License</a></li>
</ul>

<h1>
<a id="quotation" class="anchor" href="#quotation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Quotation</h1>

<p>The QDSL allows the user to write plain Scala code, leveraging scala's syntax and type system. Quotations are created using the <code>quote</code> method and can contain any excerpt of code that uses supported operations. To create quotations, first import <code>quote</code> and some other auxiliary methods:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.</span><span class="pl-v">_</span></pre></div>

<p>A quotation can be a simple value:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">pi</span> <span class="pl-k">=</span> quote(<span class="pl-c1">3.14159</span>)</pre></div>

<p>And be used within another quotation:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> pi <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre></div>

<p>Quotations can also contain high-order functions:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">area</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">c</span>: <span class="pl-en">Circle</span>) <span class="pl-k">=&gt;</span> pi <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius
}</pre></div>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> area(c))
}</pre></div>

<p>Quill's normalization engine applies reduction steps before translating the quotation to the target language. The correspondent normalized quotation for both versions of the <code>areas</code> query is:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">areas</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].map(c <span class="pl-k">=&gt;</span> <span class="pl-c1">3.14159</span> <span class="pl-k">*</span> c.radius <span class="pl-k">*</span> c.radius)
}</pre></div>

<p>Scala doesn't have support for high-order functions with type parameters. Quill supports anonymous classes with an apply method for this purpose:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">existsAny</span> <span class="pl-k">=</span> quote {
  new {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">T</span>](<span class="pl-v">xs</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>])(<span class="pl-v">p</span>: <span class="pl-en">T</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span>) <span class="pl-k">=</span>
        xs.filter(p(_)).nonEmpty
  }
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter { c1 <span class="pl-k">=&gt;</span> 
    existsAny(query[<span class="pl-en">Circle</span>])(c2 <span class="pl-k">=&gt;</span> c2.radius <span class="pl-k">&gt;</span> c1.radius)
  }
}</pre></div>

<h1>
<a id="mirror-sources" class="anchor" href="#mirror-sources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mirror sources</h1>

<p>Sources represent the database and provide an execution interface for queries. Quill provides mirror sources for test purposes. Please refer to <a href="#sources">sources</a> for information on how to create normal sources.</p>

<p>Instead of running the query, mirror sources return a structure with the information that would be used to run the query. There are two mirror source versions:</p>

<ul>
<li>
<code>io.getquill.source.mirror.mirrorSource</code>: Mirrors the quotation AST</li>
<li>
<code>io.getquill.source.sql.mirror.mirrorSource</code>: Mirrors the SQL query</li>
</ul>

<p>This documentation uses the SQL mirror in its examples under the <code>db</code> name:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> io.getquill.source.sql.mirror.mirrorSource</pre></div>

<h1>
<a id="compile-time-quotations" class="anchor" href="#compile-time-quotations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compile-time quotations</h1>

<p>Quotations are both compile-time and runtime values. Quill uses a type refinement to store the quotation's AST as an annotation available at compile-time and the <code>q.ast</code> method exposes the AST as runtime value.</p>

<p>It is important to avoid giving explicit types to quotations when possible. For instance, this quotation can't be read at compile-time as the type refinement is lost:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span><span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Circle</span>]] <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">10</span>)
}

db.run(q) <span class="pl-c">// Dynamic query</span></pre></div>

<p>Quill falls back to runtime normalization and query generation if the quotation's AST can be read at compile-time. Please refer to <a href="#dynamic-queries">dynamic queries</a> for more information</p>

<h1>
<a id="parametrized-quotations" class="anchor" href="#parametrized-quotations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parametrized quotations</h1>

<p>Quotations are designed to be self-contained, without references to runtime values outside their scope. If a quotation needs to receive a runtime value, it needs to be done by defining the quotation as a function:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Circle</span>].filter(r <span class="pl-k">=&gt;</span> r.radius <span class="pl-k">&gt;</span> i)
}</pre></div>

<p>The runtime value can be specified when running it:</p>

<div class="highlight highlight-source-scala"><pre>db.run(q).using(<span class="pl-c1">10</span>) <span class="pl-c">// SELECT r.radius FROM Circle r WHERE r.radius &gt; ?</span></pre></div>

<p>The method <code>run</code> is a bridge between the compile-time quotations and the runtime execution.</p>

<h1>
<a id="schema" class="anchor" href="#schema" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schema</h1>

<p>The database schema is represented by case classes. By default, quill uses the class and field names as the database identifiers:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Float</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>].filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

db.run(q) <span class="pl-c">// SELECT c.radius FROM Circle c WHERE c.radius &gt; 1</span></pre></div>

<p>Alternatively, the identifiers can be customized:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Circle</span>](<span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>, _.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>)
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  circles.filter(c <span class="pl-k">=&gt;</span> c.radius <span class="pl-k">&gt;</span> <span class="pl-c1">1</span>)
}

db.run(q) 
<span class="pl-c">// SELECT c.radius_column FROM circle_table c WHERE c.radius_column &gt; 1</span></pre></div>

<p>If multiple tables require custom identifiers, it is good practice to define a <code>schema</code> object with all table queries to be reused across multiple queries:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span>(<span class="pl-v">radius</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Rectangle</span>(<span class="pl-v">length</span>: <span class="pl-k">Int</span>, <span class="pl-v">width</span>: <span class="pl-k">Int</span>)
<span class="pl-k">object</span> <span class="pl-en">schema</span> {
  <span class="pl-k">val</span> <span class="pl-en">circles</span> <span class="pl-k">=</span> quote {
    query[<span class="pl-en">Circle</span>](<span class="pl-s"><span class="pl-pds">"</span>circle_table<span class="pl-pds">"</span></span>, 
      _.radius <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>radius_column<span class="pl-pds">"</span></span>)
  }
  <span class="pl-k">val</span> <span class="pl-en">rectangles</span> <span class="pl-k">=</span> quote {
    query[<span class="pl-en">Rectangle</span>](<span class="pl-s"><span class="pl-pds">"</span>rectangle_table<span class="pl-pds">"</span></span>, 
      _.length <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>length_column<span class="pl-pds">"</span></span>, 
      _.width <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>width_column<span class="pl-pds">"</span></span>)
  }
}</pre></div>

<h1>
<a id="queries" class="anchor" href="#queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Queries</h1>

<p>The overall abstraction of quill queries is use database tables as if they were in-memory collections. Scala for-comprehensions provide syntatic sugar to deal with this kind of monadic operations:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Contact</span>(<span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">phone</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  <span class="pl-k">for</span> {
    p <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Person</span>] <span class="pl-k">if</span>(p.id <span class="pl-k">==</span> <span class="pl-c1">999</span>)
    c <span class="pl-k">&lt;</span><span class="pl-k">-</span> query[<span class="pl-en">Contact</span>] <span class="pl-k">if</span>(c.personId <span class="pl-k">==</span> p.id)
  } <span class="pl-k">yield</span> {
    (p.name, c.phone)
  }
}

db.run(q) 
<span class="pl-c">// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)</span></pre></div>

<p>Quill normalizes the quotation and translates the monadic joins to applicative joins in SQL, generating a database-friendly query that avoids nested queries.</p>

<p>Any of the following features can be used together with the others and/or within a for-comprehension:</p>

<p><strong>filter</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>)
}

db.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 18</span></pre></div>

<p><strong>map</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.name)
}

db.run(q)
<span class="pl-c">// SELECT p.name FROM Person p</span></pre></div>

<p><strong>flatMap</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).flatMap(p <span class="pl-k">=&gt;</span> query[<span class="pl-en">Contact</span>].filter(c <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p.id))
}

db.run(q)
<span class="pl-c">// SELECT c.personId, c.phone FROM Person p, Contact c WHERE (p.age &gt; 18) AND (c.personId = p.id)</span></pre></div>

<p><strong>sortBy</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].sortBy(p <span class="pl-k">=&gt;</span> p.age)
}

db.run(q)
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age</span></pre></div>

<p><strong>drop/take</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].drop(<span class="pl-c1">2</span>).take(<span class="pl-c1">1</span>)
}

db.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM Person x LIMIT 1 OFFSET 2</span></pre></div>

<p><strong>groupBy</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].groupBy(p <span class="pl-k">=&gt;</span> p.age).map {
    <span class="pl-k">case</span> (age, people) <span class="pl-k">=&gt;</span>
      (age, people.size)
  }
}

db.run(q)
<span class="pl-c">// SELECT p.age, COUNT(*) FROM Person p GROUP BY p.age</span></pre></div>

<p><strong>union</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).union(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

db.run(q)
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre></div>

<p><strong>unionAll/++</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>).unionAll(query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>))
}

db.run(q) 
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">18</span>) <span class="pl-k">++</span> query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">60</span>)
}

db.run(q2) 
<span class="pl-c">// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age &gt; 18 </span>
<span class="pl-c">// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age &gt; 60) x</span></pre></div>

<p><strong>aggregation</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">r</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> p.age)
}

db.run(r.min) <span class="pl-c">// SELECT MIN(p.age) FROM Person p</span>
db.run(r.max) <span class="pl-c">// SELECT MAX(p.age) FROM Person p</span>
db.run(r.avg) <span class="pl-c">// SELECT AVG(p.age) FROM Person p</span>
db.run(r.sum) <span class="pl-c">// SELECT SUM(p.age) FROM Person p</span>
db.run(r.size) <span class="pl-c">// SELECT COUNT(p.age) FROM Person p</span></pre></div>

<p><strong>isEmpty/nonEmpty</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span> 
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).isEmpty
  }
}

db.run(q) 
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE </span>
<span class="pl-c">// NOT EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter{ p1 <span class="pl-k">=&gt;</span> 
    query[<span class="pl-en">Person</span>].filter(p2 <span class="pl-k">=&gt;</span> p2.id <span class="pl-k">!=</span> p1.id <span class="pl-k">&amp;&amp;</span> p2.age <span class="pl-k">==</span> p1.age).nonEmpty
  }
}

db.run(q2)
<span class="pl-c">// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE </span>
<span class="pl-c">// EXISTS (SELECT * FROM Person p2 WHERE (p2.id &lt;&gt; p1.id) AND (p2.age = p1.age))</span></pre></div>

<p><strong>outer joins</strong></p>

<div class="highlight highlight-source-scala"><pre>
<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].leftJoin(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p)
}

db.run(q) 
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone </span>
<span class="pl-c">// FROM Person p LEFT JOIN Contact c ON c.personId = p</span>

<span class="pl-k">val</span> <span class="pl-en">q2</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].rightJoin(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p)
}

db.run(q2) 
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone </span>
<span class="pl-c">// FROM Person p RIGHT JOIN Contact c ON c.personId = p</span>

<span class="pl-k">val</span> <span class="pl-en">q3</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].fullJoin(query[<span class="pl-en">Contact</span>]).on((p, c) <span class="pl-k">=&gt;</span> c.personId <span class="pl-k">==</span> p)
}

db.run(q3) 
<span class="pl-c">// SELECT p.id, p.name, p.age, c.personId, c.phone </span>
<span class="pl-c">// FROM Person p FULL JOIN Contact c ON c.personId = p</span></pre></div>

<h1>
<a id="actions" class="anchor" href="#actions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actions</h1>

<p>Database actions are defined using quotations as well. These actions don't have a collection-like API but rather a custom DSL to express inserts, deletes and updates.</p>

<p><strong>insert</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">personId</span>: <span class="pl-k">Int</span>, <span class="pl-v">phone</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Contact</span>].insert(_.personId <span class="pl-k">-</span><span class="pl-k">&gt;</span> personId, _.phone <span class="pl-k">-</span><span class="pl-k">&gt;</span> phone)
}

db.run(a).using(<span class="pl-en">List</span>((<span class="pl-c1">999</span>, <span class="pl-s"><span class="pl-pds">"</span>+1510488988<span class="pl-pds">"</span></span>))) 
<span class="pl-c">// INSERT INTO Contact (personId,phone) VALUES (?, ?)</span></pre></div>

<p>Note: Actions receive a <code>List</code> of tuples as they are batched by default.</p>

<p><strong>update</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span>
    query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.id <span class="pl-k">==</span> id).update(_.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> age)
}

db.run(a).using(<span class="pl-en">List</span>((<span class="pl-c1">999</span>, <span class="pl-c1">18</span>)))
<span class="pl-c">// UPDATE Person SET age = ? WHERE id = ?</span></pre></div>

<p><strong>delete</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>).delete
}

db.run(a) 
<span class="pl-c">// DELETE FROM Person WHERE name = ''</span></pre></div>

<h1>
<a id="dynamic-queries" class="anchor" href="#dynamic-queries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dynamic queries</h1>

<p>Quill's default operation mode is compile-time, but there are queries that have their structure defined only at runtime. Quill automatically falls back to runtime normalization and query generation if the query's structure is not static. Example:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Minor</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Senior</span> <span class="pl-k">extends</span> <span class="pl-e">QueryType</span>

<span class="pl-k">def</span> <span class="pl-en">people</span>(<span class="pl-v">t</span>: <span class="pl-en">QueryType</span>)<span class="pl-k">:</span> <span class="pl-en">Quoted</span>[<span class="pl-en">Query</span>[<span class="pl-en">Person</span>]] <span class="pl-k">=</span>
  t <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Minor</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>)
    }
    <span class="pl-k">case</span> <span class="pl-en">Senior</span> <span class="pl-k">=&gt;</span> quote {
      query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&gt;</span> <span class="pl-c1">65</span>)
    }
  }

db.run(people(<span class="pl-en">Minor</span>)) 
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &lt; 18</span>

db.run(people(<span class="pl-en">Senior</span>)) 
<span class="pl-c">// SELECT p.id, p.name, p.age FROM Person p WHERE p.age &gt; 65</span></pre></div>

<h1>
<a id="extending-quill" class="anchor" href="#extending-quill" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extending quill</h1>

<h2>
<a id="infix" class="anchor" href="#infix" aria-hidden="true"><span class="octicon octicon-link"></span></a>Infix</h2>

<p>Infix is a very flexible mechanism to use non-supported features without having to use plain SQL queries. It allows insertion of arbitrary SQL strings within quotations.</p>

<p>For instance, quill doesn't support the <code>FOR UPDATE</code> SQL feature. It can still be used through infix:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">forUpdate</span> <span class="pl-k">=</span> quote {
  new {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">T</span>](<span class="pl-v">q</span>: <span class="pl-en">Query</span>[<span class="pl-en">T</span>]) <span class="pl-k">=</span> infix<span class="pl-s"><span class="pl-pds">"</span>$q FOR UPDATE<span class="pl-pds">"</span></span>.as[<span class="pl-en">Query</span>[<span class="pl-en">T</span>]]
  }
}

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].filter(p <span class="pl-k">=&gt;</span> p.age <span class="pl-k">&lt;</span> <span class="pl-c1">18</span>)
}

db.run(forUpdate(a)) 
<span class="pl-c">// SELECT p.id, p.name, p.age FROM (SELECT * FROM Person p WHERE p.age &lt; 18 FOR UPDATE) p</span></pre></div>

<p>The <code>forUpdate</code> quotation can be reused for multiple queries.</p>

<p>The same approach can be used for <code>RETURNING ID</code>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">returningId</span> <span class="pl-k">=</span> quote {
  new {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">T</span>](<span class="pl-v">a</span>: <span class="pl-en">Action</span>[<span class="pl-en">T</span>]) <span class="pl-k">=</span> infix<span class="pl-s"><span class="pl-pds">"</span>$a RETURNING ID<span class="pl-pds">"</span></span>.as[<span class="pl-en">Action</span>[<span class="pl-en">T</span>]]
  }
}

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].insert(_.name <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>John<span class="pl-pds">"</span></span>, _.age <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">21</span>)
}

db.run(returningId(a))
<span class="pl-c">// INSERT INTO Person (name,age) VALUES ('John', 21) RETURNING ID</span></pre></div>

<p>A custom database function can also be used through infix:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">myFunction</span> <span class="pl-k">=</span> quote {
  (<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span> infix<span class="pl-s"><span class="pl-pds">"</span>MY_FUNCTION($i)<span class="pl-pds">"</span></span>.as[<span class="pl-k">Int</span>]
}

<span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> quote {
  query[<span class="pl-en">Person</span>].map(p <span class="pl-k">=&gt;</span> myFunction(p.age))
}

db.run(q) 
<span class="pl-c">// SELECT MY_FUNCTION(p.age) FROM Person p</span></pre></div>

<h2>
<a id="custom-encoding" class="anchor" href="#custom-encoding" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom encoding</h2>

<p>Quill uses <code>Encoder</code>s to encode runtime values defined with the <code>using</code> method and <code>Decoder</code>s to parse the query return value. The library has some encoders and decoders built-in and it is possible to provide new ones.</p>

<p>If the correspondent database type is already supported, use <code>mappedEncoding</code>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">CustomValue</span>(<span class="pl-v">i</span>: <span class="pl-k">Int</span>)

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">decodeCustomValue</span> <span class="pl-k">=</span> mappedEncoding[<span class="pl-en">CustomValue</span>, <span class="pl-k">Int</span>](_.i)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">encodeCustomValue</span> <span class="pl-k">=</span> mappedEncoding[<span class="pl-k">Int</span>, <span class="pl-en">CustomValue</span>](<span class="pl-en">CustomValue</span>(_))</pre></div>

<p>If the database type is not supported, it is possible to provide "raw" encoders and decoders:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.source.mirror.</span><span class="pl-v">Row</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">customValueEncoder</span> <span class="pl-k">=</span> 
  <span class="pl-k">new</span> <span class="pl-en">db.Encoder</span>[<span class="pl-en">CustomValue</span>] {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">index</span>: <span class="pl-k">Int</span>, <span class="pl-v">value</span>: <span class="pl-en">CustomValue</span>, <span class="pl-v">row</span>: <span class="pl-en">Row</span>) <span class="pl-k">=</span> 
      <span class="pl-k">???</span> <span class="pl-c">// database-specific implementation</span>
  }

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">customValueDecoder</span> <span class="pl-k">=</span> 
  <span class="pl-k">new</span> <span class="pl-en">db.Decoder</span>[<span class="pl-en">CustomValue</span>] {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">index</span>: <span class="pl-k">Int</span>, <span class="pl-v">row</span>: <span class="pl-en">Row</span>) <span class="pl-k">=</span> 
      <span class="pl-k">???</span> <span class="pl-c">// database-specific implementation</span>
  }</pre></div>

<h1>
<a id="sources" class="anchor" href="#sources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sources</h1>

<p>Sources represent the database and provide an execution interface for queries. Example:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.jdbc.</span><span class="pl-v">JdbcSource</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.sql.idiom.</span><span class="pl-v">MySQLDialect</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">JdbcSource</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>]</pre></div>

<h2>
<a id="dialect" class="anchor" href="#dialect" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dialect</h2>

<p>The SQL dialect to be used by the source is defined by the first type parameter. Some source types are specific to a database and thus not require it.</p>

<p>Quill has two built-in dialects:</p>

<ul>
<li><code>io.getquill.source.sql.idiom.MySQLDialect</code></li>
<li><code>io.getquill.source.sql.idiom.PostgresDialect</code></li>
</ul>

<h2>
<a id="naming-strategy" class="anchor" href="#naming-strategy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Naming strategy</h2>

<p>The second type parameter defines the naming strategy to be used when translating identifiers (table and column names) to SQL. </p>

<table>
<thead>
<tr>
<th>strategy</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>io.getquill.naming.Literal</code></td>
<td>some_ident -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.Escape</code></td>
<td>some_ident -&gt; "some_ident"</td>
</tr>
<tr>
<td><code>io.getquill.naming.UpperCase</code></td>
<td>some_ident -&gt; SOME_IDENT</td>
</tr>
<tr>
<td><code>io.getquill.naming.LowerCase</code></td>
<td>SOME_IDENT -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.SnakeCase</code></td>
<td>someIdent -&gt; some_ident</td>
</tr>
<tr>
<td><code>io.getquill.naming.CamelCase</code></td>
<td>some_ident -&gt; someIdent</td>
</tr>
</tbody>
</table>

<p>Multiple transformations can be defined using mixin. For instance, the naming strategy </p>

<p><code>SnakeCase with UpperCase</code></p>

<p>produces this transformation:</p>

<p><code>someIdent -&gt; SOME_IDENT</code></p>

<p>The transformations are applied from left to right.</p>

<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h2>

<p>Sources must be defined as <code>object</code> and the object name is used as the key to obtain configurations using the <a href="http://github.com/typesafehub/config">typesafe config</a> library.</p>

<h3>
<a id="quill-jdbc" class="anchor" href="#quill-jdbc" aria-hidden="true"><span class="octicon octicon-link"></span></a>quill-jdbc</h3>

<p><strong>MySQL</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "mysql" % "mysql-connector-java" % "5.1.36",
  "io.getquill" %% "quill-jdbc" % "0.1.0"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.jdbc.</span><span class="pl-v">JdbcSource</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.sql.idiom.</span><span class="pl-v">MySQLDialect</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">JdbcSource</span>[<span class="pl-en">MySQLDialect</span>, <span class="pl-en">SnakeCase</span>]</pre></div>

<p>application.properties</p>

<pre><code>db.dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource
db.dataSource.url=jdbc:mysql://host/database
db.dataSource.user=root
db.dataSource.password=root
db.dataSource.cachePrepStmts=true
db.dataSource.prepStmtCacheSize=250
db.dataSource.prepStmtCacheSqlLimit=2048
</code></pre>

<p><strong>Postgres</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "org.postgresql" % "postgresql" % "9.4-1206-jdbc41",
  "io.getquill" %% "quill-jdbc" % "0.1.0"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.jdbc.</span><span class="pl-v">JdbcSource</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.sql.idiom.</span><span class="pl-v">PostgresDialect</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">JdbcSource</span>[<span class="pl-en">PostgresDialect</span>, <span class="pl-en">SnakeCase</span>]</pre></div>

<p>application.properties</p>

<pre><code>db.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
db.dataSource.user=root
db.dataSource.password=root
db.dataSource.databaseName=database
db.dataSource.portNumber=5432
db.dataSource.serverName=host
</code></pre>

<p>Please refer to HikariCP's <a href="https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby">documentation</a> for a detailed explanation of the available configurations.</p>

<h3>
<a id="quill-async" class="anchor" href="#quill-async" aria-hidden="true"><span class="octicon octicon-link"></span></a>quill-async</h3>

<p><strong>MySQL Async</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async" % "0.1.0"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.async.mysql.</span><span class="pl-v">MysqlAsyncSource</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">MysqlAsyncSource</span>[<span class="pl-en">SnakeCase</span>]</pre></div>

<p>application.properties</p>

<pre><code>db.host=host
db.port=3306
db.user=root
db.password=root
db.database=database
db.poolMaxQueueSize=4
db.poolMaxObjects=4
db.poolMaxIdle=999999999
db.poolValidationInterval=100
</code></pre>

<p><strong>Postgres Async</strong></p>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-async" % "0.1.0"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.async.postgres.</span><span class="pl-v">PostgresAsyncSource</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">PostgresAsyncSource</span>[<span class="pl-en">SnakeCase</span>]</pre></div>

<p>application.properties</p>

<pre><code>db.host=host
db.port=5432
db.user=root
db.password=root
db.database=database
db.poolMaxQueueSize=4
db.poolMaxObjects=4
db.poolMaxIdle=999999999
db.poolValidationInterval=100
</code></pre>

<h3>
<a id="quill-finagle-mysql" class="anchor" href="#quill-finagle-mysql" aria-hidden="true"><span class="octicon octicon-link"></span></a>quill-finagle-mysql</h3>

<p>sbt dependencies</p>

<pre><code>libraryDependencies ++= Seq(
  "io.getquill" %% "quill-finagle-mysql" % "0.1.0"
)
</code></pre>

<p>source definition</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">import</span> <span class="pl-v">io.getquill.naming.</span><span class="pl-v">SnakeCase</span>
<span class="pl-k">import</span> <span class="pl-v">io.getquill.source.finagle.mysql.</span><span class="pl-v">FinagleMysqlSource</span>

<span class="pl-k">object</span> <span class="pl-en">db</span> <span class="pl-k">extends</span> <span class="pl-e">FinagleMysqlSource</span>[<span class="pl-en">SnakeCase</span>]</pre></div>

<p>application.properties</p>

<pre><code>testDB.dest=localhost:3306
testDB.user=root
testDB.password=root
testDB.database=database
</code></pre>

<h1>
<a id="slick-comparison" class="anchor" href="#slick-comparison" aria-hidden="true"><span class="octicon octicon-link"></span></a>Slick comparison</h1>

<p>Please refer to <a href="https://github.com/getquill/quill/blob/master/SLICK.md">SLICK.md</a> for a detailed comparison between Quill and Slick.</p>

<h1>
<a id="acknowledgments" class="anchor" href="#acknowledgments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledgments</h1>

<p>The project was created having Philip Wadler's talk <a href="http://www.infoq.com/presentations/theory-language-integrated-query">"A practical theory of language-integrated query"</a> as its initial inspiration. The development was heavily influenced by the following papers:</p>

<ul>
<li><a href="http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf">A Practical Theory of Language-Integrated Query</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf">Everything old is new again: Quoted Domain Specific Languages</a></li>
<li><a href="http://db.inf.uni-tuebingen.de/staticfiles/publications/the-flatter-the-better.pdf">The Flatter, the Better</a></li>
</ul>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h1>

<p>See the <a href="https://github.com/getquill/quill/blob/master/LICENSE.txt">LICENSE</a> file for details.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Quill maintained by <a href="https://github.com/getquill">getquill</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-65451450-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
